<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code - Optimal Merge Pattern</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* General Reset */
        body, h1, h2, h3, p {
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #f7f9fc;
            color: #333;
            line-height: 1.6;
            font-size: 16px;
        }

        /* Navbar Styling */
        .navbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .navbar a {
            color: white;
            text-decoration: none;
            font-size: 1.2em;
            margin: 0 15px;
            transition: color 0.3s;
        }

        .navbar a:hover {
            color: #ff4757;
        }

        .navbar .logo {
            font-size: 1.8em;
            font-weight: 600;
        }

        /* Code Section Styling */
        #code-section {
            background-color: #ffffff;
            padding: 60px 30px;
            text-align: center;
            max-width: 900px;
            margin: 30px auto;
            border-radius: 10px;
            box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1);
        }

        #code-section h2 {
            font-size: 2.4em;
            color: #333;
            margin-bottom: 20px;
        }

        #code-section p {
            font-size: 1.1em;
            margin-bottom: 20px;
            color: #666;
        }

        /* Code Container */
        #code-section pre {
            background-color: #1e1e1e; /* Dark background */
            padding: 20px;
            border-radius: 8px;
            font-size: 1.1em;
            color: #dcdcdc; /* Light font color */
            border: 1px solid #333;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            margin-bottom: 30px;
            text-align: left;
            overflow-x: auto;
        }

        #code-section pre code {
            font-family: "Courier New", monospace;
            font-size: 1.1em;
        }

        /* Toggle Button Container */
        .toggle-buttons {
            margin: 20px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .toggle-button {
            background-color: #667eea;
            color: white;
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .toggle-button:hover {
            background-color: #764ba2;
        }

        /* Footer Styling */
        footer {
            background-color: #333;
            color: white;
            padding: 20px 0;
            text-align: center;
        }

        footer h3 {
            margin: 0;
        }

        footer .social-icons a {
            color: white;
            font-size: 1.5em;
            margin: 0 10px;
            transition: color 0.3s;
        }

        footer .social-icons a:hover {
            color: #ff4757;
        }
    </style>
</head>
<body>

    <!-- Navbar Section -->
    <div class="navbar">
        <div class="logo">Optimal Merge</div>
        <div>
            <a href="index.html">Home</a>
            <a href="theory.html">Theory</a>
            <a href="visualization.html">Visualization</a>
            <a href="code.html">Code</a>
        </div>
    </div>

    <!-- Code Section -->
    <section id="code-section">
        <h2>Optimal Merge Pattern Code</h2>
        <p>Below is an implementation of the Optimal Merge Pattern algorithm:</p>
        
        <!-- Toggle Buttons -->
        <div class="toggle-buttons">
            <button class="toggle-button" onclick="showCode('python')">Python</button>
            <button class="toggle-button" onclick="showCode('c')">C</button>
            <button class="toggle-button" onclick="showCode('cpp')">C++</button>
            <button class="toggle-button" onclick="showCode('java')">Java</button>
            <button class="toggle-button" onclick="showCode('js')">JavaScript</button>
            <button class="toggle-button" onclick="showCode('ts')">TypeScript</button>
            <button class="toggle-button" onclick="showCode('explanation')">Explanation</button>
        </div>

        <!-- Code Blocks -->
        <pre id="code-python"><code>
def optimal_merge(files):
    import heapq
    heapq.heapify(files)
    total_cost = 0

    while len(files) > 1:
        first = heapq.heappop(files)
        second = heapq.heappop(files)
        cost = first + second
        total_cost += cost
        heapq.heappush(files, cost)

    return total_cost
        </code></pre>

        <pre id="code-c" style="display:none"><code>
#include <stdio.h>
#include <stdlib.h>

void optimalMerge(int files[], int n) {
    // Your C code implementation
#include <stdio.h>
#include <stdlib.h>

// Function to calculate the minimum cost of merging files
int optimalMerge(int files[], int n) {
    // Sort the array of file sizes in ascending order
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (files[j] > files[j + 1]) {
                int temp = files[j];
                files[j] = files[j + 1];
                files[j + 1] = temp;
            }
        }
    }

    int totalCost = 0;

    // Merge the smallest files iteratively
    for (int i = 1; i < n; i++) {
        // Sum the two smallest files
        int cost = files[0] + files[1];
        totalCost += cost;

        // Replace the first two files with their sum
        files[0] = cost;

        // Shift the array to the left by one position
        for (int j = 1; j < n - i; j++) {
            files[j] = files[j + 1];
        }

        // Re-sort the array to maintain the order
        for (int j = 0; j < n - i - 1; j++) {
            if (files[j] > files[j + 1]) {
                int temp = files[j];
                files[j] = files[j + 1];
                files[j + 1] = temp;
            }
        }
    }

    return totalCost;
}

int main() {
    int files[] = {5, 2, 4, 7};
    int n = sizeof(files) / sizeof(files[0]);

    printf("Minimum cost of merging files: %d\n", optimalMerge(files, n));
    return 0;
}

}
        </code></pre>

        <pre id="code-cpp" style="display:none"><code>
#include <iostream>
#include <queue>
using namespace std;

int optimalMerge(vector<int> &files) {
    // Your C++ code implementation
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// Function to calculate the minimum cost of merging files
int optimalMerge(vector<int> &files) {
    // Priority queue (min-heap) to store the file sizes
    priority_queue<int, vector<int>, greater<int>> minHeap;

    // Push all file sizes into the priority queue
    for (int file : files) {
        minHeap.push(file);
    }

    int totalCost = 0;

    // Merge files until only one file remains
    while (minHeap.size() > 1) {
        // Extract the two smallest files
        int first = minHeap.top();
        minHeap.pop();
        int second = minHeap.top();
        minHeap.pop();

        // Calculate the cost of merging these two files
        int mergeCost = first + second;
        totalCost += mergeCost;

        // Push the merged file size back into the priority queue
        minHeap.push(mergeCost);
    }

    return totalCost;
}

int main() {
    vector<int> files = {20, 30, 10, 5, 30}; // Example file sizes
    cout << "Minimum cost of merging files: " << optimalMerge(files) << endl;
    return 0;
}

}
        </code></pre>

        <pre id="code-java" style="display:none"><code>
import java.util.PriorityQueue;

public class OptimalMerge {
    public static int optimalMerge(int[] files) {
        // Your Java code implementation
import java.util.PriorityQueue;

public class OptimalMerge {

    public static int optimalMerge(int[] files) {
        // Using a PriorityQueue (min-heap) to store the file sizes
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        // Add all files into the priority queue
        for (int file : files) {
            minHeap.add(file);
        }

        int totalCost = 0;

        // Keep merging the two smallest files until only one file remains
        while (minHeap.size() > 1) {
            // Remove the two smallest files
            int first = minHeap.poll();
            int second = minHeap.poll();

            // Calculate the cost of merging them
            int cost = first + second;
            totalCost += cost;

            // Add the merged file back to the queue
            minHeap.add(cost);
        }

        return totalCost;
    }

    public static void main(String[] args) {
        // Example usage
        int[] files = {10, 20, 30, 5}; // File sizes
        int result = optimalMerge(files);

        System.out.println("Minimum cost of merging files: " + result);
    }
}

    }
}
        </code></pre>
	 <pre id="code-js" style="display:none"><code>
function optimalMerge(files) {
    // Your JavaScript code implementation
function optimalMerge(files) {
    // Create a priority queue using a min-heap
    const minHeap = [...files].sort((a, b) => a - b); // Sort array to simulate min-heap
    let totalCost = 0;

    while (minHeap.length > 1) {
        // Extract the two smallest elements
        const first = minHeap.shift();
        const second = minHeap.shift();

        // Calculate merge cost
        const mergeCost = first + second;
        totalCost += mergeCost;

        // Insert the merged file back into the min-heap
        minHeap.push(mergeCost);
        minHeap.sort((a, b) => a - b); // Maintain the heap property
    }

    return totalCost;
}

// Example usage
const files = [20, 30, 10, 5];
console.log("Minimum cost of merging:", optimalMerge(files));

}
        </code></pre>


        <pre id="code-ts" style="display:none"><code>
function optimalMerge(files: number[]): number {
    // Your TypeScript code implementation
function optimalMerge(files: number[]): number {
    // Importing a priority queue equivalent in TypeScript
    class MinHeap {
        private heap: number[];

        constructor(arr: number[]) {
            this.heap = [...arr];
            this.buildHeap();
        }

        private buildHeap() {
            for (let i = Math.floor(this.heap.length / 2) - 1; i >= 0; i--) {
                this.heapifyDown(i);
            }
        }

        private heapifyDown(index: number) {
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            let smallest = index;

            if (leftChild < this.heap.length && this.heap[leftChild] < this.heap[smallest]) {
                smallest = leftChild;
            }

            if (rightChild < this.heap.length && this.heap[rightChild] < this.heap[smallest]) {
                smallest = rightChild;
            }

            if (smallest !== index) {
                [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
                this.heapifyDown(smallest);
            }
        }

        private heapifyUp(index: number) {
            const parent = Math.floor((index - 1) / 2);

            if (index > 0 && this.heap[index] < this.heap[parent]) {
                [this.heap[index], this.heap[parent]] = [this.heap[parent], this.heap[index]];
                this.heapifyUp(parent);
            }
        }

        public extractMin(): number {
            if (this.heap.length === 0) {
                throw new Error("Heap is empty");
            }

            const min = this.heap[0];
            const end = this.heap.pop();

            if (this.heap.length > 0 && end !== undefined) {
                this.heap[0] = end;
                this.heapifyDown(0);
            }

            return min;
        }

        public insert(value: number) {
            this.heap.push(value);
            this.heapifyUp(this.heap.length - 1);
        }

        public size(): number {
            return this.heap.length;
        }
    }

    // Main logic for Optimal Merge
    const minHeap = new MinHeap(files);
    let totalCost = 0;

    while (minHeap.size() > 1) {
        const first = minHeap.extractMin();
        const second = minHeap.extractMin();
        const cost = first + second;
        totalCost += cost;
        minHeap.insert(cost);
    }

    return totalCost;
}

// Example usage:
const fileSizes = [5, 2, 4, 7];
console.log("Minimum cost of merging files:", optimalMerge(fileSizes));

}
        </code></pre>

        <pre id="code-explanation" style="display:none"><code>
The Optimal Merge Pattern works by merging the smallest files first. This ensures...
        </code></pre>

    </section>

    <!-- Footer Section -->
    <footer>
        <h3>&copy; 2024 Optimal Merge Pattern. All Rights Reserved.</h3>
        <div class="social-icons">
            <a href="https://www.facebook.com"><i class="fab fa-facebook"></i></a>
            <a href="https://www.twitter.com"><i class="fab fa-twitter"></i></a>
            <a href="https://www.linkedin.com"><i class="fab fa-linkedin"></i></a>
        </div>
    </footer>

    <script>
        function showCode(language) {
            const codeBlocks = document.querySelectorAll("pre");//Selects all <pre> elements
            codeBlocks.forEach((block) => (block.style.display = "none"));//sets their display property to none.
            //matching code-{language} and changes its display to block
            document.getElementById(`code-${language}`).style.display = "block";
        }
    </script>
</body>
</html>
